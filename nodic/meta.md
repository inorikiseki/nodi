```yml

meta
nodic : meta
0, 1
null, being
null -> 0
being -> 1
'1 : 0
'0 : 1
bit : [0 1]
true, false
bool'boolean : [true false]
byte : [bit]^8
u8 : byte'
  !(physical based)
  (real implement)
u16 : [u8]^2
u32 : [u8]^4, u32 : [u16]^2
f8 : byte'
(real implement)
f16 : [f8]^2
f32 : [f16]^2, f32 : [f8]^4
integer : u8 | u16 | u32
float : f8 | f16 | f32
number : integer | float
digit : [0 1 2 3 4 5 6 7 8 9]
letter :
  lowercase :
    [
    a b c d e f g
    h i j k l m n
    o p q r s t
    u v w x y z
    ]  
  uppercase :
    [
    A B C D E F G
    H I J K L M N
    O P Q O P Q
    U V W X Y Z
    ]
symbol :
  [
  ! @ # $ % ^ & * ( ) - + ...
  ]
```

```yml nodic

meta
0, 1
null, being
```
## null-being 0-1
// After meta, the first differentiation is to tell exsitence and non-existence, which is
// null and being, but also the basic differentiator is 0, 1. How to expresss and what's the 
// relationship between null-being and 0-1? Actually, that's where the context is going to shine 
// AGAIN.  They are the same in some context, and not the same when being differentiated. 
// The 0-1 is capable of expressing null-being pair. But, not vice verser always. 0-1 is
// more general in a way, but when expressing BEGIN, you have to tell exsitence and non-exsitence
// with the null-beign pair before you can fucntioning the main role of 0-1.
// For a summary, 0-1 is more general, then null-being is the differentiaton of part of 0-1 role,
// the null-being itself is the delegation of 0-1.
// Thus, even 0-1 is not the same concept with meta and 0 and 1. The group it self have its another
// -dimension meaning or type-entity.
// To tell this layer of differences, we use 0-1-2..* to express.

Thus, we may take this definition.
null - being : 0 - 1
The '-' does not matter that much, others are the same for the purpose. To 
get rid of symbol rigidity, we need a generic expression. That is, use larger symbol set
than single symbol or smaller one. 

null [- ,] being : 0 [- ,] 1


null meta being : 0 meta 1
Yes, even the meta.


Another topic.
To reuse a former statement you not gonna type repitively, use the symbol it or 'it or whatever. 
But maybe a real symbol that's not consisted of letters will more clear in a sense.

null [- ,] being : 0 it 1
However, the 'it' itself introduce so much vague, cause it's too generic. For the alternation of 
a mid-operation you will use mid, op or whatever.
null [- ,] being : 0 

Polished.
null [- ,] being : 0 it'op 1
null [- ,] being : 0 (former op) 1

And of course, the more free you use, the more complex the semantic space will end out, and the more 
devague or disambiguation is needed for looking-back resortion.

We may think more on the 'the' in the next time.

## ' shiftor, mirror.
```
'1 : 0
'0 : 1
```
this is not to say that ' is function the same as !(NOT). Actually, they are the 
same in an aspective with 0-1 pair level.

The ' functioning as a mirror marker.
it links to the mirror context world.
The 0-1 contrast relationship is one of the mirror relationship.
so '0 is related to '1.

Yin <-> Yang
'Yin  : Yang
'Yang : Yin

I just start the topic here, more extending later on. Maybe.











